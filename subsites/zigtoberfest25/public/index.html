<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">Un-locking Zig</title>
    <link rel="stylesheet" type="text/css" href="/global.css">
    
	<style>
		body {
			margin: 2rem auto;
		}

		h1 {
			text-align: center;
		}

		nav {
			align-self: center;
		}

		.block {
			border: var(--border);
			border-radius: var(--radius);
		}

		.block p {
			padding-top: 0;
			font-size: 0.9em;
			padding-left: 15px;
			padding-right: 15px;
		}

		.block h1 {
			font-size: 1.17em;
			position: relative !important;
			margin: 0 !important;
			text-align: left;
			padding-left: 15px;
			padding-right: 15px;
			padding-top: 2px !important;
			background-color: var(--highlight);
			font-weight: normal;
		}

		table {
			border-spacing: .5em .5em;
		}

		th {
			text-align: start;
		}

		td {
			vertical-align: top;
		}
	</style>
	<script defer src="https://analytics.pietzschmann.org/script.js" data-website-id="a5f865ea-b760-403b-8525-2fdce9397a84"></script>

  </head>
  <body>
    <nav id="menu" class="centered">
      <a href="/talks">Go Back</a> • <a href="/">Main Site</a> • <a href="/unlockedzig.pdf" target="_blank">Slides</a>
    </nav>
    <div id="content">
      
	<h1 class="centered title">Un-locking Zig</h1>
		<!-- <p class="centered tagline"> -->
		<!--   Zigtoberfest 2024 -->
		<!-- </p> -->
	<div id="page"><p>For the <a href="https://web.archive.org/web/20251208200114/https://zigtoberfest.de/" target="_blank">Zigtoberfest 2025</a> I gave a talk about lock-free — or non-blocking — data structures. This page provides a small summary of the talk.</p><p>Not in a reading mood? Let me do the talking over on YouTube:</p><p style="padding-bottom: 56.25%; max-width: 100%; position: relative;">
    <iframe
        width="560"
        height="315"
        src="https://www.youtube-nocookie.com/embed/TJrgOTj0zmI?si=m8ETgEC1Q_4RRaou"
        title="Lock-free data structures in Zig (Lukas Pietzschmann, Zigtoberfest 2025)"
        frameborder="0"
        allow="clipboard-write; encrypted-media; picture-in-picture; web-share"
        style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;"
        referrerpolicy="strict-origin-when-cross-origin"
        allowfullscreen
    ></iframe>
</p>
<h1>Intro</h1><p>Do you like cooking? Also with multiple people at the same time? If so, you might have experienced the problem of multiple cooks trying to use the same utensil at the same time. You are constantly blocking each other from using the single available knife, someone is always cutting the veggies wrong, and in the end, it takes longer than if you just cooked alone.</p><p>It’s the same with programming. When multiple threads try to access the same data structure at the same time, they need to coordinate their access. Usually, this is done with locks like mutexes, semaphores, or read-write locks. And while locks are a simple and often times effective solution, one can easily overlook their flaws.</p><p>Just to name a few hidden costs:</p><ul><li><strong>Contention</strong>: When multiple threads try to acquire the same lock, they have to wait for each other, leading to performance degradation.</li><li><strong>Deadlocks</strong>: If two or more threads are waiting for each other to release locks, they can end up in a deadlock situation where none of them can proceed.</li><li><strong>Priority Inversion</strong>: A lower-priority thread holding a lock can block a higher priority thread, leading to suboptimal scheduling and performance issues.</li><li><strong>Composability</strong>: Combining multiple lock-based data structures can lead to complex locking hierarchies, increasing the risk of deadlocks and making reasoning about the code more difficult.</li></ul><p>So … can we synchronize access without using locks?</p><h1>How to go lock-free</h1><p>To get rid of locks, we need to rethink the critical section. If it were so small, that it wouldn’t be possible for multiple threads to enter it at the same time, locks would be obsolete. This is where <em>atomic operations</em> come into play.</p><p>Atomic operations are hardware-supported, meaning that the CPU directly ensures that no intermediate results are visible to other threads. Zig provides access to those instructions through built-ins like <code>@atomicLoad</code>, <code>@atomicStore</code>, and <code>@cmpxchgStrong</code>. The latter is especially interesting, as it powers most lock-free data structures. We call it <em>Compare And Swap</em> (CAS). This is how it could be implemented non-atomically:</p><pre><code>fn cas(comptime T: type, ptr: *T, expected: T, new: T) ?T {
    if (ptr.* != expected) {
        return null;
    }
    const old = ptr.*;
    ptr.* = new;
    return old;
}
</code></pre><p>The idea is simple: We want to update the value at <code>ptr</code> to <code>new</code> if, and only if, its current value is <code>expected</code> (so nobody else changed the state underneath us). If the current value is not <code>expected</code>, we fail and don’t change anything. In reality, Zig’s <code>@cmpxchgStrong</code> will directly compile down to the respective CPU instruction without any of the above logic happening in software.</p><p>Typically, CAS is further composed into a CAS-loop. I’ll show this using a Stack’s push operation:</p><pre><code>fn push(self: *Stack, value: T) !void {
    var new_head = try self.allocator.create(Node);
    new_head.* = Node{
        .value = value,
        .next = null,
    };

    while (true) {
        const old_head = @atomicLoad(&amp;self.head, .acquire);
        new_head.next = old_head;
        if (@cmpxchgStrong(&amp;self.head, old_head, new_head,
            .release, .acquire) == null) {
            return; // success, exit the function
        }
        // failed, try again
    }
}
</code></pre><p>Now that you have a rough idea of how lock-free data structures work, let’s further look at some properties and considerations.</p><h1>Freedom</h1><p>In contrast to lock-based data structures, where arguing about progression guarantees is tricky, non-blocking data structures can fulfill different levels of <em>freeness</em>.</p><ul><li><strong>Obstruction-freedom</strong>: The weakest form of freeness. A thread can make progress if it runs in isolation. However, if multiple threads are contending, they might prevent each other from making progress.</li><li><strong>Lock-freedom</strong>: A stronger guarantee. At least one thread will make progress in a finite number of steps, regardless of contention. This ensures system-wide progress, but individual threads might still starve.</li><li><strong>Wait-freedom</strong>: The strongest guarantee. Every thread will make progress in a finite number of steps, regardless of contention. This ensures both system-wide progress and individual thread progress, eliminating starvation.</li></ul><p>With this hierarchy, stronger guarantees automatically entail weaker ones.</p><p>Every non-blocking data structure is always at least obstruction-free. Achieving lock-freedom is also easy, as most CAS-loops are lock-free by design. Think about it: A CAS of one thread can only fail if another thread successfully changed the state by progressing. Wait-freedom, however, is harder to achieve and often requires more complex algorithms or additional helping mechanisms. <em>E.g.</em>, threads could reserve certain memory slots for themselves to ensure they can always make progress when accessing those. Or Threads could also help each other by completing each other’s operations ( non-blocking implementations of queues often uses this technique).</p><h1>Considerations</h1><p>Another thing we can reason about is the correct memory ordering of our operations. In essence, we have the problem that the CPU as well as the compiler will reorder instruction to, <em>e.g.</em>, hide latencies. While this is usually beneficial for performance, it can lead to unexpected behavior in concurrent programs, as semantic data dependencies might not be obvious to the optimizer.</p><p>To have control over this, we can introduce certain types of <em>memory barriers</em> or <em>orderings</em> to our atomic operations. Zig (through LLVM) supports the following:</p><ul><li><strong>unordered</strong>: No ordering guarantees. Don’t bother with this.</li><li><strong>monotonic</strong>: Operations accessing the same address will happen in a consistent order.</li><li><strong>acquire</strong>: Ensures that subsequent reads and writes cannot be reordered before this operation.</li><li><strong>release</strong>: Ensures that previous reads and writes cannot be reordered after this operation.</li><li><strong>acq_rel</strong>: Combines the effects of both acquire and release.</li><li><strong>sequentially_consistent</strong>: The strongest ordering. Ensures a total order of operations across all threads.</li></ul><p>Know what? Most of the time, this should work: Put a <code>.release</code> on your writes and a <code>.acquire</code> on your reads. When in doubt, go with <code>.seq_cst</code>, this will cost you a bit of performance, but ensure correctness.</p><h1>Challenges</h1><p>While lock-free data structures have many advantages, they also come with their own set of challenges. A common one is the <em>ABA problem</em>. Consider the following illustration:</p><p><img src="/talks/zigtoberfest25/redlight.png"> <img src="/talks/zigtoberfest25/greenlight.png"> <img src="/talks/zigtoberfest25/redlight.png"></p><p>Here, the driver is waiting at a red light until it turns green. However, since they have to wait for so long, they get sleepy and don’t notice when the light turns green. Only after the light has turned red again do they wake up. From the driver’s perspective, the light never changed, even though it did.</p><p>This can also happen in lock-free data structures. Imagine a thread reads a value <code>A</code> from a shared variable. Before it can perform a CAS operation to update the value, another thread changes the value from <code>A</code> to <code>B</code> and then back to <code>A</code>. When the first thread performs the CAS operation, it sees that the value is still <code>A</code> and successfully updates it, unaware that the value had changed in the meantime.</p><p>When working with pointers, this can quickly corrupt the data structure, leading to undefined and definitely unwanted behavior.</p><p>To mitigate the ABA problem, several techniques can be employed:</p><ul><li><strong>DCAS</strong>: Double CAS can atomically compare and swap two memory locations. To mitigate the ABA problem, one location can hold the actual data pointer, while the other holds a version counter. Each time the data is modified, the version counter is incremented. This way, even if the data pointer returns to its original value, the version counter will differ, allowing threads to detect changes.</li><li><strong>Tagged Pointers</strong>: Since DCAS is not always available and memory alignment usually leaves some pointer bits unused, we can also use those bits to store a counter. Similar to DCAS, this counter is incremented with each modification, helping to detect changes even if the pointer value returns to its original state.</li><li><strong>Hazard Pointers</strong>: A memory reclamation technique where threads announce which pointers they might access. Before reclaiming memory, a thread checks if any other thread has announced a hazard pointer pointing to that memory. If so, the memory is not reclaimed, preventing some ABA related issues.</li></ul><h1>TL;DR</h1><p>Now how do I decide whether to use lock-free data structures or not? Here are some guidelines:</p><ul><li>Your application is not performance critical: Don’t bother, slap a Mutex on it</li><li>You want to orchestrate threads and not just protect data: Again, go with locks</li><li>Optimizing for throughput under high contention is your dream: Lock-free it is</li><li>You need real-time guarantees and low latency: Lock-free is the way to go</li></ul><div class="block info"><h1></h1><p>Don’t be afraid to use locks, but don’t limit yourself to them either!</p></div></div>

    </div>
  </body>
</html>